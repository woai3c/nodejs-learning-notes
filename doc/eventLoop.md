# EventLoop 事件循环
当 Node.js 启动后，它会初始化事件循环，处理已提供的输入脚本，它可能会调用一些异步的 API、调度定时器，或者调用 `process.nextTick()`，然后开始处理事件循环。

## 事件循环阶段
下面的图表展示了事件循环操作顺序的简化概览。
```
   ┌───────────────────────────┐
┌─>│           timers          │
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
│  │     pending callbacks     │
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
│  │       idle, prepare       │
│  └─────────────┬─────────────┘      ┌───────────────┐
│  ┌─────────────┴─────────────┐      │   incoming:   │
│  │           poll            │<─────┤  connections, │
│  └─────────────┬─────────────┘      │   data, etc.  │
│  ┌─────────────┴─────────────┐      └───────────────┘
│  │           check           │
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
└──┤      close callbacks      │
   └───────────────────────────┘
```
**注意：每个框被称为事件循环机制的一个阶段**。

每个阶段都有一个 FIFO 队列来执行回调，当事件循环进入某个阶段时，会执行该阶段队列中的回调。当该队列都已执行完或达到回调限制，事件循环将进入到下一阶段。

**阶段概述**
* 定时器：本阶段执行已经被 `setTimeout()` 和 `setInterval()` 调度的回调函数。
* 待定回调：执行延迟到下一个循环迭代的 I/O 回调。
* idle, prepare：仅系统内部使用。
* 轮询：检索新的 I/O 事件;执行与 I/O 相关的回调（不包含关闭的回调函数、`setTimeout()`、`setInterval()`、`setImmediate()`），其余情况 node 将在适当的时候在此阻塞。
* 检测：`setImmediate()` 回调函数在这里执行。
* 关闭的回调函数：一些关闭的回调函数，如：`socket.on('close', ...)`。

### timers 定时器阶段
轮询阶段会在 `setTimeout()`、`setInterval()` 定时器指定时间到达后把回调函数推到定时器队列，然后在事件循环进入到定时器阶段后执行这些回调函数。

**注意**：轮询阶段控制定时器何时执行。

### pending callbacks 待定回调阶段
此阶段对某些系统操作（如 TCP 错误类型）执行回调。例如，如果 TCP 套接字在尝试连接时接收到 ECONNREFUSED，则某些 *nix 的系统希望等待报告错误。这将被排队以在**待定回调**阶段执行。

### poll 轮询阶段
轮询阶段有两个重要的功能：
* 计算应该阻塞和轮询 I/O 的时间。
* 然后，处理轮询队列里的事件。

当事件循环进入轮询阶段且没有被调度的定时器时，将发生以下两种情况之一：
* **如果轮询队列不是空**的，事件循环将循环访问回调队列并同步执行它们，直到队列已用尽，或者达到了与系统相关的硬性限制。
* **如果轮询队列是空**的，还有两件事发生：
   + 如果脚本被 `setImmediate()` 调度，则事件循环将结束轮询阶段，并继续**检测**阶段以执行那些被调度的脚本。
   + 如果脚本未被 `setImmediate()` 调度，则事件循环将**等待**回调被添加到队列中，然后立即执行。

如果轮询队列为空，事件循环会检查是否有定时器已经达到了时间阈值。如果一个或多个定时器已准备就绪，则事件循环将回到定时器阶段以执行这些定时器的回调。

### check 检测阶段
此阶段会执行 `setImmediate()` 上的回调。`setImmediate()` 实际上是一个在事件循环的单独阶段运行的特殊计时器。它使用一个 libuv API 来安排回调在轮询阶段完成后执行。

通常，在执行代码时，事件循环最终会命中轮询阶段，在那等待传入连接、请求等。但是，如果回调已使用 `setImmediate()` 调度过，并且轮询阶段变为空闲状态，则它将结束此阶段，并进入到检测阶段。

### close callbacks 关闭的回调函数阶段
如果套接字或处理函数突然关闭（例如 socket.destroy()），则 `close` 事件将在这个阶段发出。否则它将通过 `process.nextTick()` 发出。

### 小结
1. 如果轮询队列不为空，则执行轮询队列上的回调。
2. 如果轮询队列为空，则查看是否有 `setImmediate()` 的回调，如果有，则进入下一阶段。
3. 否则一直停留在轮询阶段，直到有回调被添加到队列中。假设在这个阶段有定时器达到了时间阈值，则会跳转到定时器阶段。

## setImmediate() 对比 setTimeout()
`setImmediate()` 和 `setTimeout()` 很类似，但是基于被调用的时机，他们也有不同表现。
* `setImmediate()` 设计为一旦在当前轮询阶段完成，就执行脚本。
* `setTimeout()` 在最小阈值（ms 单位）过后运行脚本。

如果是在模块内执行，`setTimeout()`、`setImmediate()` 两者间的先后执行顺序不定，但如果是在 I/O 事件回调里调用 `setTimeout()`、`setImmediate()`，则 `setImmediate()` 优先执行。

## 微任务和宏任务
#### 微任务
* `process.nextTick()`
* Promise

#### 宏任务
* `setTimeout()`
* `setImmediate()`
* `setInterval()`
* I/O 事件

#### 宏、微任务的区别
* 微任务优先级比宏任务高
* 执行完所有的微任务之后，才会执行宏任务
* 每执行一个宏任务之后都会去执行微任务

## 参考资料
* [Node.js 事件循环，定时器和 process.nextTick()](https://nodejs.org/zh-cn/docs/guides/event-loop-timers-and-nexttick/)
